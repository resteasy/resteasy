<chapter id="Content_Marshalling_Providers">
   <title>Content Marshalling/Providers</title>
   <sect1 id="Default_Providers_and_default_JAX-RS_Content_Marshalling">
      <title>Default Providers and default JAX-RS Content Marshalling</title>

      <para>

         Resteasy can automatically marshal and unmarshal a few different message bodies.
      </para>
      <para>

         <table frame="topbot">
            <tgroup cols="2" rowsep="1" colsep="1">
               <thead>
                  <row>
                     <entry>
                        Media Types
                     </entry>
                     <entry>
                        Java Type
                     </entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry>
                        application/*+xml, text/*+xml, application/*+json, application/*+fastinfoset, application/atom+*
                     </entry>
                     <entry>
                        JaxB annotated classes
                     </entry>
                  </row>
                  <row>
                     <entry>
                        */*
                     </entry>
                     <entry>
                        java.lang.String
                     </entry>
                  </row>
                  <row>
                     <entry>
                        */*
                     </entry>
                     <entry>
                        java.io.InputStream
                     </entry>
                  </row>
                  <row>
                     <entry>
                        text/plain
                     </entry>
                     <entry>
                        primtives, java.lang.String, or any type that has a String constructor, or static
                        valueOf(String) method for input, toString() for output
                     </entry>
                  </row>
                  <row>
                     <entry>
                        */*
                     </entry>
                     <entry>
                        javax.activation.DataSource
                     </entry>
                  </row>
                  <row>
                     <entry>
                        */*
                     </entry>
                     <entry>
                        java.io.File
                     </entry>
                  </row>
                  <row>
                     <entry>
                        */*
                     </entry>
                     <entry>
                        byte[]
                     </entry>
                  </row>
                  <row>
                     <entry>
                        application/x-www-form-urlencoded
                     </entry>
                     <entry>
                        javax.ws.rs.core.MultivaluedMap
                     </entry>
                  </row>
               </tbody>
            </tgroup>
         </table>

      </para>
      <para>

      </para>
      <para>

      </para>
      <para>


      </para>
   </sect1>
   <sect1 id="Content_Marshalling_with__Provider_classes">
      <title>Content Marshalling with @Provider classes</title>

      <para>

         The JAX-RS specification allows you to plug in your own request/response body reader and writers. To do this,
         you annotate a class
         with @Provider and specify the @Produces types for a writer and @Consumes types for a reader. You must
         also implement
         a MessageBodyReader/Writer interface respectively. Here is an example.
      </para>
      <para>


         The Resteasy ServletContextLoader will automatically scan your WEB-INF/lib and classes directories for classes
         annotated with @Provider or you can manually configure them in web.xml. See Installation/Configuration
      </para>
      <para>


      </para>
   </sect1>
   <sect1 id="MessageBodyWorkers">
      <title>Providers Utility Class</title>

      <para>

         javax.ws.rs.ext.Providers is a simple injectable interface that allows you to look up MessageBodyReaders,
          Writers, ContextResolvers, and ExceptionMappers. It is very useful, for instance, for implementing
          multipart providers. Content types that embed
         other random content types.
      </para>
      <para>

         <programlisting>
<![CDATA[
public interface Providers
{

   /**
    * Get a message body reader that matches a set of criteria. The set of
    * readers is first filtered by comparing the supplied value of
    * {@code mediaType} with the value of each reader's
    * {@link javax.ws.rs.Consumes}, ensuring the supplied value of
    * {@code type} is assignable to the generic type of the reader, and
    * eliminating those that do not match.
    * The list of matching readers is then ordered with those with the best
    * matching values of {@link javax.ws.rs.Consumes} (x/y > x&#47;* > *&#47;*)
    * sorted first. Finally, the
    * {@link MessageBodyReader#isReadable}
    * method is called on each reader in order using the supplied criteria and
    * the first reader that returns {@code true} is selected and returned.
    *
    * @param type        the class of object that is to be written.
    * @param mediaType   the media type of the data that will be read.
    * @param genericType the type of object to be produced. E.g. if the
    *                    message body is to be converted into a method parameter, this will be
    *                    the formal type of the method parameter as returned by
    *                    <code>Class.getGenericParameterTypes</code>.
    * @param annotations an array of the annotations on the declaration of the
    *                    artifact that will be initialized with the produced instance. E.g. if the
    *                    message body is to be converted into a method parameter, this will be
    *                    the annotations on that parameter returned by
    *                    <code>Class.getParameterAnnotations</code>.
    * @return a MessageBodyReader that matches the supplied criteria or null
    *         if none is found.
    */
   <T> MessageBodyReader<T> getMessageBodyReader(Class<T> type,
                                                 Type genericType, Annotation annotations[], MediaType mediaType);

   /**
    * Get a message body writer that matches a set of criteria. The set of
    * writers is first filtered by comparing the supplied value of
    * {@code mediaType} with the value of each writer's
    * {@link javax.ws.rs.Produces}, ensuring the supplied value of
    * {@code type} is assignable to the generic type of the reader, and
    * eliminating those that do not match.
    * The list of matching writers is then ordered with those with the best
    * matching values of {@link javax.ws.rs.Produces} (x/y > x&#47;* > *&#47;*)
    * sorted first. Finally, the
    * {@link MessageBodyWriter#isWriteable}
    * method is called on each writer in order using the supplied criteria and
    * the first writer that returns {@code true} is selected and returned.
    *
    * @param mediaType   the media type of the data that will be written.
    * @param type        the class of object that is to be written.
    * @param genericType the type of object to be written. E.g. if the
    *                    message body is to be produced from a field, this will be
    *                    the declared type of the field as returned by
    *                    <code>Field.getGenericType</code>.
    * @param annotations an array of the annotations on the declaration of the
    *                    artifact that will be written. E.g. if the
    *                    message body is to be produced from a field, this will be
    *                    the annotations on that field returned by
    *                    <code>Field.getDeclaredAnnotations</code>.
    * @return a MessageBodyReader that matches the supplied criteria or null
    *         if none is found.
    */
   <T> MessageBodyWriter<T> getMessageBodyWriter(Class<T> type,
                                                 Type genericType, Annotation annotations[], MediaType mediaType);

   /**
    * Get an exception mapping provider for a particular class of exception.
    * Returns the provider whose generic type is the nearest superclass of
    * {@code type}.
    *
    * @param type the class of exception
    * @return an {@link ExceptionMapper} for the supplied type or null if none
    *         is found.
    */
   <T extends Throwable> ExceptionMapper<T> getExceptionMapper(Class<T> type);

   /**
    * Get a context resolver for a particular type of context and media type.
    * The set of resolvers is first filtered by comparing the supplied value of
    * {@code mediaType} with the value of each resolver's
    * {@link javax.ws.rs.Produces}, ensuring the generic type of the context
    * resolver is assignable to the supplied value of {@code contextType}, and
    * eliminating those that do not match. If only one resolver matches the
    * criteria then it is returned. If more than one resolver matches then the
    * list of matching resolvers is ordered with those with the best
    * matching values of {@link javax.ws.rs.Produces} (x/y > x&#47;* > *&#47;*)
    * sorted first. A proxy is returned that delegates calls to
    * {@link ContextResolver#getContext(java.lang.Class)} to each matching context
    * resolver in order and returns the first non-null value it obtains or null
    * if all matching context resolvers return null.
    *
    * @param contextType the class of context desired
    * @param mediaType   the media type of data for which a context is required.
    * @return a matching context resolver instance or null if no matching
    *         context providers are found.
    */
   <T> ContextResolver<T> getContextResolver(Class<T> contextType,
                                             MediaType mediaType);
}
]]>
         </programlisting>
      </para>
      <para>


      </para>
      <para>

         A Providers instance is injectable into MessageBodyReader or Writers:
      </para>
      <para>

         <programlisting>
            @Provider
            @Consumes("multipart/fixed")
            public class MultipartProvider implements MessageBodyReader {

            private @Context Providers providers;

            ...

            }
         </programlisting>
      </para>
      <para>


      </para>
   </sect1>
   <sect1 id="Built_in_JAXB_providers">
      <title>JAXB providers</title>

      <para>

         As required by the specification, RESTEasy JAX-RS includes support for (un)marshalling JAXB annotated classes.
         RESTEasy provides multiple JAXB Providers to address some subtle differences between classes generated by XJC
         and classes which are simply annotated with @XmlRootElement, or working with JAXBElement classes directly.
      </para>
      <para>

         For the most part, developers using the JAX-RS API, the selection of which provider is invoked will be
         completely transparent. For developers wishing to access the providers directly (which most folks won't need to
         do), this document describes which provider is best suited for different configurations.
      </para>
      <para>

         A JAXB Provider is selected by RESTEasy when a parameter or return type is an object that is annotated with
         JAXB annotations (such as @XmlRootEntity or @XmlType) or if the type is a JAXBElement. Additionally, the
         resource class or resource method will be annotated with either a @Consumes or @Produces annotation and
         contain one or more of the following values:
      </para>
      <para>

         <itemizedlist>

            <listitem>
               text/*+xml
            </listitem>

            <listitem>
               application/*+xml
            </listitem>

            <listitem>
               application/*+fastinfoset
            </listitem>

            <listitem>
               application/*+json
            </listitem>

         </itemizedlist>

      </para>
      <para>

      </para>
      <para>

         RESTEasy will select a different provider based on the return type or parameter type used in the resource. This
         section decribes how the selection process works.
      </para>
      <para>

         @XmlRootEntity
         When a class is annotated with a @XmlRootElement annotation, RESTEasy will select the
         JAXBXmlRootElementProvider. This provider handles basic marhaling and and unmarshalling of custom JAXB
         entities.
      </para>
      <para>

         @XmlType
         Classes which have been generated by XJC will most likely not contain an @XmlRootEntity annotation. In order
         for these classes to marshalled, they must be wrapped within a JAXBElement instance. This is typically
         accomplished by invoking a method on the class which serves as the XmlRegistry and is named ObjectFactory.
      </para>
      <para>

         The JAXBXmlTypeProvider provider is selected when the class is annotated with an XmlType annotation and not an
         XmlRootElement annotation.
      </para>
      <para>

         This provider simplifies this task by attempting to locate the XmlRegistry for the target class. By default, a
         JAXB implementation will create a class called ObjectFactory and is located in the same package as the target
         class. When this class is located, it will contain a &quot;create&quot; method that takes the object instance
         as a parameter. For example, of the target type is called &quot;Contact&quot;, then the ObjectFactory class
         will have a method:
      </para>
      <para>

         public JAXBElement createContact(Contact value) {..
      </para>
      <para>

         JAXBElement&lt;?&gt;
         If your resource works with the JAXBElement class directly, the RESTEasy runtime will select the
         JAXBElementProvider. This provider examines the ParameterizedType value of the JAXBElement in order to select
         the appropriate JAXBContext.
      </para>
      <para>

      </para>
      <para>


      </para>
      <sect2 id="Pluggable_JAXBContext_s_with_ContextResolvers">
         <title>Pluggable JAXBContext's with ContextResolvers</title>

         <para>

            You should not use this feature unless you know what you're doing.
         </para>
         <para>

            Based on the class you are marshalling/unmarshalling, RESTEasy will, by default create and cache JAXBContext
            instances per class type. If you do not want RESTEasy to create JAXBContexts, you can plug-in your own by
            implementing an instance of javax.ws.rs.ext.ContextResolver
         </para>
         <para>

<programlisting>
public interface ContextResolver&lt;T&gt;
{
   T getContext(Class&lt;?&gt; type);
}

@Provider
@Produces("application/xml")
public class MyJAXBContextResolver implements ContextResolver&lt;JAXBContext&gt;
{
   JAXBContext getContext(Class&lt;?&gt; type)
   {
      if (type.equals(WhateverClassIsOverridedFor.class)) return JAXBContext.newInstance()...;
   }
}
            </programlisting>
         </para>
         <para>

            You must provide a @Produces annotation to specify the media type the context is meant for. You must also
            make sure to implement ContextResolver&lt;JAXBContext&gt;. This helps the runtime match to the correct
            context resolver. You must also annotate the ContextResolver class with @Provider.
         </para>
         <para>

            There are multiple ways to make this ContextResolver available.
         </para>
         <para>

            <orderedlist>

               <listitem>
                  Return it as a class or instance from a javax.ws.rs.core.Application implementation
               </listitem>

               <listitem>
                  List it as a provider with resteasy.providers
               </listitem>

               <listitem>
                  Let RESTEasy automatically scan for it within your WAR file. See Configuration Guide
               </listitem>

               <listitem>
                  Manually add it via ResteasyProviderFactory.getInstance().registerProvider(Class) or
                  registerProviderInstance(Object)
               </listitem>

            </orderedlist>

         </para>
         <para>


         </para>
      </sect2>
      <sect2 id="JAXB_+_XML_provider">
         <title>JAXB + XML provider</title>
      </sect2>
      <sect2 id="JAXB_+_JSON_provider">
         <title>JAXB + JSON provider</title>

         <para>

            RESTEasy allows you to marshall JAXB annotated POJOs to and from JSON. This provider wraps the Jettison JSON
            library to accomplish this.  You can obtain more information about Jettison and how it works from:
         </para>
	 <para>
	    http://jettison.codehaus.org/
	 </para>
         <para>
	   Jettison has two mapping formats. One is BadgerFish the other is a Jettison
           Mapped Convention format.  The Mapped Convention is the default mapping.
         </para>
         <para>

         </para>
         <para>

            For example, consider this JAXB class:
         </para>
         <para>

<programlisting>
@XmlRootElement(name = "book")
public class Book
{
   private String author;
   private String ISBN;
   private String title;

   public Book()
   {
   }

   public Book(String author, String ISBN, String title)
   {
      this.author = author;
      this.ISBN = ISBN;
      this.title = title;
   }

   @XmlElement
   public String getAuthor()
   {
      return author;
   }

   public void setAuthor(String author)
   {
      this.author = author;
   }

   @XmlElement
   public String getISBN()
   {
      return ISBN;
   }

   public void setISBN(String ISBN)
   {
      this.ISBN = ISBN;
   }

   @XmlAttribute
   public String getTitle()
   {
      return title;
   }

   public void setTitle(String title)
   {
      this.title = title;
   }
}
            </programlisting>
         </para>
         <para>


         </para>
         <para>

            This is how the JAXB Book class would be marshalled to JSON using the BadgerFish Convention
         </para>
         <para>

<programlisting>
{"book":
       {
          "@title":"EJB 3.0",
          "author":{"$":"Bill Burke"},
          "ISBN":{"$":"596529260"}
       }
}
</programlisting>
         </para>
         <para>

            Notice that element values have a map associated with them and to get to the value of the element, you must
            access the &quot;$&quot; variable. Here's an example of accessing the book in Javascript:
         </para>
         <para>

<programlisting>
var data = eval("(" + xhr.responseText + ")");
document.getElementById("zone").innerHTML = data.book.@title;
document.getElementById("zone").innerHTML += data.book.author.$;
</programlisting>
         </para>
         <para>


         </para>
         <para>

            To use the BadgerFish Convention you must use the
            @org.jboss.resteasy.annotations.providers.jaxb.json.BadgerFish annotation on the JAXB class you are
            marshalling/unmarshalling, or, on the JAX-RS resource method or parameter:
         </para>
         <para>

<programlisting>
@BadgerFish
@XmlRootElement(name = "book")
public class Book {...}
</programlisting>
         </para>
         <para>

            If you are returning a book on the JAX-RS method and you don't want to (or can't) pollute your JAXB classes
            with RESTEasy annotations, add the annotation to the JAX-RS method:
         </para>
         <para>

<programlisting>
@BadgerFish
@GET
public Book getBook(...) {...}
</programlisting>
         </para>
         <para>

            If a Book is your input then you put it on the parameter:
         </para>
         <para>

<programlisting>
@POST
public void newBook(@BadgerFish Book book) {...}
</programlisting>
         </para>
         <para>


         </para>
         <para>

            The default Jettison Mapped Convention would return JSON that looked like this:
         </para>
         <para>

<programlisting>
{ "book" :
         {
            "@title":"EJB 3.0",
            "author":"Bill Burke",
            "ISBN":596529260
          }
}
</programlisting>
         </para>
         <para>

            Notice that the @XmlAttribute &quot;title&quot; is prefixed with the '@' character. Unlike BadgerFish, the
            '$' does not represent the value of element text. This format is a bit simpler than the BadgerFish
            convention which is why it was chose as a default. Here's an example of accessing this in Javascript:
         </para>
         <para>

<programlisting>
var data = eval("(" + xhr.responseText + ")");
document.getElementById("zone").innerHTML = data.book.@title;
document.getElementById("zone").innerHTML += data.book.author;
</programlisting>
         </para>
         <para>


         </para>
         <para>

            The Mapped Convention allows you to fine tune the JAXB mapping using the
            @org.jboss.resteasy.annotations.providers.jaxb.json.Mapped annotation. You can provide an XML Namespace to
            JSON namespace mapping. For example, if you defined your JAXB namespace within your package-info.java class like this:
	 </para>
<programlisting>
@javax.xml.bind.annotation.XmlSchema(namespace="http://jboss.org/books")
package org.jboss.resteasy.test.books;
</programlisting>
	 <para>
         You would have to define a JSON to XML namespace mapping or you would receive an exception of something like this:
	 </para>
<programlisting>
java.lang.IllegalStateException: Invalid JSON namespace: http://jboss.org/books
at org.codehaus.jettison.mapped.MappedNamespaceConvention.getJSONNamespace(MappedNamespaceConvention.java:151)
at org.codehaus.jettison.mapped.MappedNamespaceConvention.createKey(MappedNamespaceConvention.java:158)
at org.codehaus.jettison.mapped.MappedXMLStreamWriter.writeStartElement(MappedXMLStreamWriter.java:241) 
</programlisting>
         <para>
           To fix this problem you need another annotation, @Mapped.  You use the @Mapped annotation on your JAXB classes, on your JAX-RS resource method, or on
           the parameter you are unmarshalling
	 </para>
<programlisting>
import org.jboss.resteasy.annotations.providers.jaxb.json.Mapped;
import org.jboss.resteasy.annotations.providers.jaxb.json.XmlNsMap;

...

   @GET
   @Produces("application/json")
   @Mapped(namespaceMap = {
           @XmlNsMap(namespace = "http://jboss.org/books", jsonName = "books")
   })
   public Book get() {...}

</programlisting>
         <para>
         Besides mapping XML to JSON namespaces, you can also force @XmlAttribute's to be marshaled as XMLElements.
         </para>
         <para>

            <programlisting>
               @Mapped(attributeAsElements={"title"})
               @XmlRootElement(name = "book")
               public class Book {...}
            </programlisting>
         </para>
         <para>

            If you are returning a book on the JAX-RS method and you don't want to (or can't) pollute your JAXB classes
            with RESTEasy annotations, add the annotation to the JAX-RS method:
         </para>
         <para>

            <programlisting>
               @Mapped(attributeAsElements={"title"})
               @GET
               public Book getBook(...) {...}
            </programlisting>
         </para>
         <para>

            If a Book is your input then you put it on the parameter:
         </para>
         <para>

<programlisting>
@POST
public void newBook(@Mapped(attributeAsElements={"title"}) Book book) {...}
</programlisting>
         </para>
         <para>

         </para>
         <para>

         </para>
         <para>

         </para>
         <para>

         </para>
         <para>

         </para>
         <para>


         </para>
      </sect2>
      <sect2 id="JAXB_+_FastinfoSet_provider">
         <title>JAXB + FastinfoSet provider</title>

         <para>

            RESTEasy supports the FastinfoSet mime type with JAXB annotated classes. Fast infoset documents are faster
            to serialize and parse, and smaller in size, than logically equivalent XML documents. Thus, fast infoset
            documents may be used whenever the size and processing time of XML documents is an issue. It is configured
            the same way the XML JAXB provider is so really no other documentation is needed here.
         </para>
         <para>


         </para>
      </sect2>
      <sect2 id="JAXB_Collections">
         <title>Arrays and Collections of JAXB Objects</title>
         <para>
            RESTEasy will automatically 
            marshal arrays, java.util.Set's, and java.util.List's of JAXB objects to and from XML, JSON, Fastinfoset (or any other new JAXB mapper Restasy comes up with).
         </para>
<programlisting><![CDATA[
@XmlRootElement(name = "customer")
@XmlAccessorType(XmlAccessType.FIELD)
public class Customer
{
   @XmlElement
   private String name;

   public Customer()
   {
   }

   public Customer(String name)
   {
      this.name = name;
   }

   public String getName()
   {
      return name;
   }
}

@Path("/")
public class MyResource
{
      @PUT
      @Path("array")
      @Consumes("application/xml")
      public void putCustomers(Customer[] customers)
      {
         Assert.assertEquals("bill", customers[0].getName());
         Assert.assertEquals("monica", customers[1].getName());
      }

      @GET
      @Path("set")
      @Produces("application/xml")
      public Set<Customer> getCustomerSet()
      {
         HashSet<Customer> set = new HashSet<Customer>();
         set.add(new Customer("bill"));
         set.add(new Customer("monica"));

         return set;
      }


      @PUT
      @Path("list")
      @Consumes("application/xml")
      public void putCustomers(List<Customer> customers)
      {
         Assert.assertEquals("bill", customers.get(0).getName());
         Assert.assertEquals("monica", customers.get(1).getName());
      }
}
]]>
</programlisting>
      <para>
         The above resource can publish and receive JAXB objects.  It is assumed that are wrapped in a collection element
      </para>
<programlisting><![CDATA[
<collection>
   <customer><name>bill</name></customer>
   <customer><name>monica</name></customer>
<collection>
]]>
</programlisting>
      <para>You can change the namespace URI, namespace tag, and collection element name by using the @org.jboss.resteasy.annotations.providers.jaxb.Wrapped annotation on a parameter or method</para>
<programlisting>
@Target({ElementType.PARAMETER, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Wrapped
{
   String element() default "collection";

   String namespace() default "http://jboss.org/resteasy";

   String prefix() default "resteasy";
}
</programlisting>
   <para>So, if we wanted to output this XML</para>
<programlisting><![CDATA[
<foo:list xmlns:foo="http://foo.org">
   <customer><name>bill</name></customer>
   <customer><name>monica</name></customer>
</foo:list>
]]>
</programlisting>
   <para>We would use the @Wrapped annotation as follows: </para>
<programlisting><![CDATA[
      @GET
      @Path("list")
      @Produces("application/xml")
      @Wrapped(element="list", namespace="http://foo.org", prefix="foo")
      public List<Customer> getCustomerSet()
      {
         List<Customer> list = new ArrayList<Customer>();
         list.add(new Customer("bill"));
         list.add(new Customer("monica"));

         return list;
      }
]]>
</programlisting>
     <sect3 id="json_list">
       <title>JSON and JAXB Collections/arrays</title>
       <para>Resteasy supports using collections with JSON.  It encloses lists, sets, or arrays of returned JAXB objects within a simple
       JSON array.  For example:</para>
<programlisting>
  @XmlRootElement
   @XmlAccessorType(XmlAccessType.FIELD)
   public static class Foo
   {
      @XmlAttribute
      private String test;

      public Foo()
      {
      }

      public Foo(String test)
      {
         this.test = test;
      }

      public String getTest()
      {
         return test;
      }

      public void setTest(String test)
      {
         this.test = test;
      }
   }
</programlisting>
    <para>This a List or array of this Foo class would be represented in JSON like this:</para>
<programlisting>
<![CDATA[
[{"foo":{"@test":"bill"}},{"foo":{"@test":"monica}"}}]
]]>
</programlisting>
    <para>It also expects this format for input</para>
     </sect3>
   </sect2>
      <sect2 id="JAXB_Map">
         <title>Maps of JAXB Objects</title>
         <para><![CDATA[
            RESTEasy will automatically 
            marshal maps of JAXB objects to and from XML, JSON, Fastinfoset (or any other new JAXB mapper Restasy comes up with).
            Your parameter or method return type must be a generic with a String as the key and the JAXB object's type.
        ]]></para>
<programlisting><![CDATA[
   @XmlRootElement(namespace = "http://foo.com")
   public static class Foo
   {
      @XmlAttribute
      private String name;

      public Foo()
      {
      }

      public Foo(String name)
      {
         this.name = name;
      }

      public String getName()
      {
         return name;
      }
   }

   @Path("/map")
   public static class MyResource
   {
      @POST
      @Produces("application/xml")
      @Consumes("application/xml")
      public Map<String, Foo> post(Map<String, Foo> map)
      {
         Assert.assertEquals(2, map.size());
         Assert.assertNotNull(map.get("bill"));
         Assert.assertNotNull(map.get("monica"));
         Assert.assertEquals(map.get("bill").getName(), "bill");
         Assert.assertEquals(map.get("monica").getName(), "monica");
         return map;
      }
}
]]>
</programlisting>
      <para>
         The above resource can publish and receive JAXB objects within a map.  By default, they are wrapped in a "map" element in the
         default namespace.  Also, each "map" element has zero or more "entry" elements with a "key" attribute.
      </para>
<programlisting><![CDATA[
<map>
   <entry key="bill" xmlns="http://foo.com">
       <foo name="bill"/>
   </entry>
   <entry key="monica" xmlns="http://foo.com">
       <foo name="monica"/>
   </entry>
</map>
]]>
</programlisting>
      <para>You can change the namespace URI, namespace prefix and map, entry, and key element and attribute names by using the @org.jboss.resteasy.annotations.providers.jaxb.WrappedMap annotation on a parameter or method</para>
<programlisting>
@Target({ElementType.PARAMETER, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface WrappedMap
{
   /**
    * map element name
    */
   String map() default "map";

   /**
    * entry element name *
    */
   String entry() default "entry";

   /**
    * entry's key attribute name
    */
   String key() default "key";

   String namespace() default "";

   String prefix() default "";
}
</programlisting>
   <para>So, if we wanted to output this XML</para>
<programlisting><![CDATA[
<hashmap>
   <hashentry hashkey="bill" xmlns:foo="http://foo.com">
       <foo:foo name="bill"/>
   </hashentry>
</map>
]]>
</programlisting>
   <para>We would use the @WrappedMap annotation as follows: </para>
<programlisting><![CDATA[
   @Path("/map")
   public static class MyResource
   {
      @GET
      @Produces("application/xml")
      @WrappedMap(map="hashmap", entry="hashentry", key="hashkey")
      public Map<String, Foo> get()
      {
         ...
         return map;
      }
]]>
</programlisting>
     <sect3 id="json_map">
       <title>JSON and JAXB maps</title>
       <para>Resteasy supports using maps with JSON.  It encloses maps returned JAXB objects within a simple
       JSON map.  For example:</para>
<programlisting>
  @XmlRootElement
   @XmlAccessorType(XmlAccessType.FIELD)
   public static class Foo
   {
      @XmlAttribute
      private String test;

      public Foo()
      {
      }

      public Foo(String test)
      {
         this.test = test;
      }

      public String getTest()
      {
         return test;
      }

      public void setTest(String test)
      {
         this.test = test;
      }
   }
</programlisting>
    <para>This a List or array of this Foo class would be represented in JSON like this:</para>
<programlisting>
<![CDATA[
{ "entry1" : {"foo":{"@test":"bill"}}, "entry2" : {"foo":{"@test":"monica}"}}}
]]>
</programlisting>
    <para>It also expects this format for input</para>
     </sect3>
   </sect2>
   <sect2 id="JAXB_INTERFACES">
      <title>Interfaces, Abstract Classes, and JAXB</title>
      <para>
       Some objects models use abstract classes and interfaces heavily.  Unfortunately, JAXB doesn't work with interfaces
       that are root elements and RESTEasy can't unmarshal parameters that are interfaces or raw abstract classes because
       it doesn't have enough information to create a JAXBContext.  For example:
      </para>
<programlisting>
public interface IFoo {}

@XmlRootElement
public class RealFoo implements IFoo {}

@Path("/jaxb")
public class MyResource {

   @PUT
   @Consumes("application/xml")
   public void put(IFoo foo) {...}
}
</programlisting>
   <para>
     In this example, you would get an error from RESTEasy of something like "Cannot find a MessageBodyReader for...".  This is because
     RESTEasy does not know that implementations of IFoo are JAXB classes and doesn't know how to create a JAXBContext for it.  As a workaround,
    RESTEasy allows you to use the JAXB annotation @XmlSeeAlso on the interface to correct the problem.  (NOTE, this will not work with manual, hand-coded JAXB).
   </para>
<programlisting>
@XmlSeeAlso(RealFoo.class)
public interface IFoo {}
</programlisting>
   <para>
   The extra @XmlSeeAlso on IFoo allows RESTEasy to create a JAXBContext that knows how to unmarshal RealFoo instances.
   </para>
   </sect2>
   </sect1>
   <sect1 id="Built_in_YAML_Provider">
      <title>YAML Provider</title>

      <para>

         Since Beta 6, resteasy comes with built in support for YAML using the Jyaml library. To enable YAML support,
         you need to drop in the jyaml-1.3.jar in RestEASY's classpath.
      </para>
      <para>


      </para>
      <para>

         Jyaml jar file can either be downloaded from sourceforge:
         https://sourceforge.net/project/showfiles.php?group_id=153924
      </para>
      <para>

         Or if you use maven, the jyaml jar is available through the main repositories and included using this
         dependency:
      </para>
      <para>

<programlisting>
&lt;dependency&gt;
   &lt;groupId&gt;org.jyaml&lt;/groupId&gt;
   &lt;artifactId&gt;jyaml&lt;/artifactId&gt;
   &lt;version&gt;1.3&lt;/version&gt;
&lt;/dependency&gt;
         </programlisting>
      </para>
      <para>

         When starting resteasy look out in the logs for a line stating that the YamlProvider has been added - this
         indicates that resteasy has found the Jyaml jar:
      </para>
      <para>

         2877 Main INFO org.jboss.resteasy.plugins.providers.RegisterBuiltin - Adding YamlProvider
      </para>
      <para>


      </para>
      <para>

         The Yaml provider recognises three mime types:
      </para>
      <para>

         <itemizedlist>

            <listitem>
               text/x-yaml
            </listitem>

            <listitem>
               text/yaml
            </listitem>

            <listitem>
               application/x-yaml
            </listitem>

         </itemizedlist>

      </para>
      <para>


      </para>
      <para>

         This is an example of how to use Yaml in a resource method.
      </para>
      <para>

<programlisting>
import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;

@Path("/yaml")
public class YamlResource
{

   @GET
   @Produces("text/x-yaml")
   public MyObject getMyObject() {
      return createMyObject();
   }
   ...
}
</programlisting>
      </para>
      <para>

      </para>
      <para>

      </para>
      <para>


      </para>
   </sect1>
   &Multipart;
   &Atom;
   &Json;
</chapter>
