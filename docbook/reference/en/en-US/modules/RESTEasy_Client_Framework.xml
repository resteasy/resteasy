<chapter id="RESTEasy_Client_Framework">
    <title>RESTEasy Client API</title>

    <section>
        <title>&REST-API; Client API</title>
        <para>The &REST-API; includes a client API so the user can make http requests to remote RESTful web services.
        It is a 'fluent' request building API with really 3 main classes:  Client, WebTarget, and Response.  The Client
        interface is a builder of WebTarget instances.  WebTarget represents a distinct URL or URL template from which
        the user can build more sub-resource WebTargets or invoke requests on.</para>
        <para>
            There are really two ways to create a Client.  Standard way, or to use the ResteasyClientBuilder class.
            The advantage of the latter is that it provides a few more helper methods to configure the client.
        </para>
        <programlisting>
            Client client = ClientBuilder.newClient();
            ... or...
            Client client = ClientBuilder.newBuilder().build();
            WebTarget target = client.target("http://foo.com/resource");
            Response response = target.request().get();
            String value = response.readEntity(String.class);
            response.close();  // You should close connections!

            Client client = ClientBuilder.newClient();
            WebTarget target = client.target("http://foo.com/resource");
        </programlisting>
        <para>
            RESTEasy will automatically load a set of default providers. (Basically all classes listed in all
            META-INF/services/jakarta.ws.rs.ext.Providers files).  Additionally, other providers,
            filters, and interceptors can be manually registered through the Configuration object provided by the method call Client.configuration().
            Configuration also lets the user set various configuration properties that may be needed.
        </para>
        <para>
            Each WebTarget has its own Configuration instance which inherits the components and properties registered with
            its parent.  This allows the user to set specific configuration options per target resource.  For example, username
            and password.
        </para>
        
        <para>
        One RESTEasy extension to the client API is the ability to specify that requests should be sent in "chunked" transfer mode.
        There are two ways of doing that. One is to configure an <classname>org.jboss.resteasy.client.jaxrs.ResteasyWebTarget</classname>
        so that all requests to that target are sent in chunked mode:
        </para>
        
        <programlisting>
      ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();
      ResteasyWebTarget target = client.target("http://localhost:8081/test");
      target.setChunked(b.booleanValue());
      Invocation.Builder request = target.request();
        </programlisting>
        
        <para>
        Alternatively, it is possible to configure a particular request to be sent in chunked mode:
        </para>
        
        <programlisting>
      ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();
      ResteasyWebTarget target = client.target("http://localhost:8081/test");
      ClientInvocationBuilder request = (ClientInvocationBuilder) target.request();
      request.setChunked(b);
        </programlisting>
        
        <para>
        Note that <classname>org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder</classname>,
        unlike <classname>jakarta.ws.rs.client.Invocation.Builder</classname>, is a RESTEasy class.
        </para>
        
        <para>
        <emphasis role="bold">Note. </emphasis> The ability to send in chunked mode depends on the underlying
        transport layer; in particular, it depends on which implementation of
        <classname>org.jboss.resteasy.client.jaxrs.ClientHttpEngine</classname> is being used. Currently,
        only the default implementation, <classname>ApacheHttpClient43Engine</classname>,
        supports chunked mode. See Section <link linkend='transport_layer'>Apache HTTP Client 4.x and other backends</link>
        for more information.
        </para>

		<note>
			<para>
	          To follow REST principles and avoid introducing state management in applications, <classname>jakarta.ws.rs.client.Client</classname>
                instances do not provide support for cookie management by default.
	          However, the user can enable it if necessary using <classname>ResteasyClientBuilder</classname>:
			</para>
			<programlisting>
				Client client = ((ResteasyClientBuilder) ClientBuilder.newBuilder()).enableCookieManagement().build();
			</programlisting>
		</note>
    </section>
    <para>

    </para>

    <section id="proxies">
        <title>RESTEasy Proxy Framework</title>
    <para>

        The RESTEasy Proxy  Framework is the mirror opposite of the &REST-API; server-side specification. Instead of using
        &REST-API; annotations to map an incoming request to RESTFul Web Service methods, the client framework builds an
        HTTP request that it uses to invoke a remote RESTful Web Service. This remote service does not have to be a
        &REST-API; service and can be any web resource that accepts HTTP requests.
    </para>
    <para>

        RESTEasy has a client proxy framework that allows the use of &REST-API; annotations to
        invoke a remote HTTP resource.  Write a Java interface and use &REST-API; annotations on methods
        and the interface. For example:
    </para>
    <para>

<programlisting>
public interface SimpleClient
{
   @GET
   @Path("basic")
   @Produces("text/plain")
   String getBasic();

   @PUT
   @Path("basic")
   @Consumes("text/plain")
   void putBasic(String body);

   @GET
   @Path("queryParam")
   @Produces("text/plain")
   String getQueryParam(@QueryParam("param")String param);

   @GET
   @Path("matrixParam")
   @Produces("text/plain")
   String getMatrixParam(@MatrixParam("param")String param);

   @GET
   @Path("uriParam/{param}")
   @Produces("text/plain")
   int getUriParam(@PathParam("param")int param);
}</programlisting>
    </para>
    <para>

        RESTEasy has a simple API to generate a proxy, then invoke methods on the
        proxy. The invoked method gets translated to an HTTP request based on how the method was annotated
        and posted to the server. Here's how to set this up:
    </para>
    <para>

        <programlisting>
            Client client = ClientBuilder.newClient();
            WebTarget target = client.target("http://example.com/base/uri");
            ResteasyWebTarget rtarget = (ResteasyWebTarget)target;

            SimpleClient simple = rtarget.proxy(SimpleClient.class);
            simple.putBasic("hello world");
        </programlisting>
        Alternatively use the RESTEasy client extension interfaces directly:
        <programlisting>
            ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();
            ResteasyWebTarget target = client.target("http://example.com/base/uri");

            SimpleClient simple = target.proxy(SimpleClient.class);
            simple.putBasic("hello world");
        </programlisting>

    </para>
    <para>

        @CookieParam works the mirror opposite of its server-side counterpart and creates a cookie
        header to send to the server.
        It is not needed to use @CookieParam if you allocate your own jakarta.ws.rs.core.Cookie
        object and pass it as a parameter to a client proxy method. The client framework understands
        the cookie is being passed to the server so no extra metadata is needed.
    </para>
    <para>
     The framework supports the &REST-API; locator pattern, but on the client side.  So, if there is
        a method annotated only with @Path, that proxy method
     will return a new proxy of the interface returned by that method.
    </para>
    <section id="Custom_client-side_responses">
        <title>Abstract Responses</title>

        <para>
            Sometimes there is interest in viewing the response status code and/or the response headers
            in addition to the response body of the client request.
            The Client-Proxy framework has two ways to get at this information
        </para>
        <para>


        </para>
        <para>
            A jakarta.ws.rs.core.Response.Status enumeration can be returned from the method.
        </para>
        <para>

            <programlisting>
@Path("/")
public interface MyProxy {
   @POST
   Response.Status updateSite(MyPojo pojo);
}
            </programlisting>
        </para>
        <para>

            Internally, after invoking the server, the client proxy internals will convert the HTTP response
            code into a Response.Status enum.
        </para>
        <para>


        </para>
        <para>
            The jakarta.ws.rs.core.Response class provides all accessible information:
        </para>
        <para>

            <programlisting>
@Path("/")
public interface LibraryService {

   @GET
   @Produces("application/xml")
   Response getAllBooks();
}</programlisting>
        </para>
     </section>
     
    <section id="Response_proxies">
        <title>Response proxies</title>
        <para>
           A further extension implemented by the RESTEasy client proxy framework is the "response proxy facility",
           where a client proxy method returns an interface that represents the information
           contained in a <classname>jakarta.ws.rs.core.Response</classname>. Such an interface must be annotated with
           <classname>@ResponseObject</classname> from package <classname>org.jboss.resteasy.annotations</classname>,
           and its methods may be further annotated with <classname>@Body</classname>, <classname>@LinkHeaderParam</classname>,
           and <classname>@Status</classname> from the same package,  as well as <classname>jakarta.ws.rs.HeaderParam</classname>.
           Consider the following example.
        </para>
        
        <programlisting>
   @ResponseObject
   public interface TestResponseObject {
      
      @Status
      int status();

      @Body
      String body();

      @HeaderParam("Content-Type")
      String contentType();
      
      ClientResponse response();
   }

   @Path("test")
   public interface TestClient {
   
      @GET
      TestResponseObject get();
   }

   @Path("test")
   public static class TestResource {

      @GET
      @Produces("text/plain")
      public String get() {
         return "ABC";
      }
   }
        </programlisting>
        
        <para>
           Here, <classname>TestClient</classname> will define the client side proxy for <classname>TestResource</classname>.
           Note that <methodname>TestResource.get()</methodname> returns a <classname>String</classname> but the proxy
           based on <classname>TestClient</classname> will return a <classname>TestResponseObject</classname> on a 
           call to <methodname>get()</methodname>:
        </para>

        <programlisting>
      Client client = ClientBuilder.newClient();
      TestClient ClientInterface = ProxyBuilder.builder(TestClient.class, client.target("http://localhost:8081")).build();
      TestResponseObject tro = ClientInterface.get();
        </programlisting>
        
        <para>
           The methods of <classname>TestResponseObject</classname> provide access to various pieces of information about the
           response received from <methodname>TestResponse.get()</methodname>. This is where the annotations on those methods
           come into play. <methodname>status()</methodname> is annotated with <classname>@Status</classname>, and a call to
           <methodname>status()</methodname> returns the HTTP status. Similarly, <methodname>body()</methodname> returns the
           returned entity, and <methodname>contentType()</methodname> returns the value of the response header Content-Type:
        </para>
        
        <programlisting>
      System.out.println("status: " + tro.status());
      System.out.println("entity: " + tro.body());
      System.out.println("Content-Type: " + tro.contentType());
        </programlisting>
        
        <para>
           will yield
        </para>

        <programlisting>
status: 200
entity: ABC
Content-Type: text/plain;charset=UTF-8        
        </programlisting>
        
        <para>
           Note that there is one other method in <classname>TestResponseObject</classname>, <methodname>response()</methodname>,
           that has no annotation. When RESTEasy sees a method in an interface annotated with <classname>@ResponseObject</classname>
           that returns a <classname>jakarta.ws.rs.core.Response</classname> (or a subclass thereof), it will return a
           <classname>org.jboss.resteasy.client.jaxrs.internal.ClientResponse</classname>. For example,
        </para>
        
        <programlisting>
      ClientResponse clientResponse =  tro.response();
      System.out.println("Content-Length: " + clientResponse.getLength());
        </programlisting>
        
        <para>
           Perhaps the most interesting piece of the response proxy facility is the treatment of methods 
           annotated with <classname>@LinkHeaderParam</classname>. Its simplest use is to assist in 
           accessing a <classname>jakarta.ws.rs.core.Link</classname> returned by a resource method. For
           example, let's add
        </para>
        
        <programlisting>
      @GET
      @Path("/link-header")
      public Response getWithHeader(@Context UriInfo uri) {
         URI subUri = uri.getAbsolutePathBuilder().path("next-link").build();
         Link link = new LinkBuilderImpl().uri(subUri).rel("nextLink").build();
         return Response.noContent().header("Link", link.toString()).build();
      }
        </programlisting>
        
        <para>
           to <classname>TestResource</classname>, add
        </para>
        
        <programlisting>
       @GET
       @Path("link-header")
       ResponseObjectInterface performGetBasedOnHeader();
        </programlisting>
        
        <para>
           to <classname>ClientInterface</classname>, and add
        </para>
        
        <programlisting>
       @LinkHeaderParam(rel = "nextLink")
       URI nextLink();
        </programlisting>
        
        <para>
           to <classname>ResponseObjectInterface</classname>. Then calling       
        </para>
        
        <programlisting>
      ResponseObjectInterface obj = ClientInterface.performGetBasedOnHeader();
      System.out.println("nextLink(): " + obj.nextLink());
        </programlisting>
        
        <para>
           will access the <classname>LinkHeader</classname> returned by <methodname>TestResource.getWithHeader()</methodname>:
        </para>
        
        <programlisting>
nextlink: http://localhost:8081/test/link-header/next-link
        </programlisting>
        
        <para>
           Last but not least, let's add
        </para>
        
        <programlisting>
      @GET
      @Produces("text/plain")
      @Path("/link-header/next-link")
      public String getHeaderForward() {
         return "forwarded";
      }
        </programlisting>
        
        <para>
           to <classname>TestResource</classname> and
        </para>
        
        <programlisting>
       @GET
       @LinkHeaderParam(rel = "nextLink")
       String followNextLink();
        </programlisting>
        
        <para>
           to <classname>ResponseObjectInterface</classname>. Note that, unlike
           <methodname>ResponseObjectInterface.nextLink()</methodname>, <methodname>followNextLink()</methodname>
           is annotated with <classname>@GET</classname>; that is, it qualifies as (the client proxy to) a resource
           method. When executing <methodname>followNextLink()</methodname>, RESTEasy will retrieve the value
           of the <classname>Link</classname> returned by <methodname>TestResource.getWithHeader()</methodname>
           and then will make a GET invocation on the <classname>URL</classname> in that <classname>Link</classname>.
           Calling
        </para>
        
        <programlisting>
      System.out.println("followNextLink(): " + obj.followNextLink());
        </programlisting>
        
        <para>
           causes RESTEasy to retrieve the <classname>URL</classname> http://localhost:8081/test/link-header/next-link
           from the call to <methodname>TestResource.getWithHeader()</methodname> and then perform a GET on it,
           invoking <methodname>TestResource.getHeaderForward()</methodname>:
        </para>
        
        <programlisting>
followNextLink(): forwarded
        </programlisting>
        
        <para><emphasis role="bold">Note.</emphasis> This facility for extracting a <classname>URL</classname>
        and following it is a step toward supporting the Representation State Transfer principle of HATEOAS.
        For more information, see
        <ulink url="http://shop.oreilly.com/product/0636920028925.do">RESTful Java with JAX-RS 2.0, 2nd Edition</ulink>
        by Bill Burke.
        </para>
    </section>
    
    <section id="ClientURI">
      <title>Giving client proxy an ad hoc URI</title>
      
      <para>
          Client proxies figure out appropriate URIs for targeting resource methods by looking at <classname>@Path</classname> 
          annotations in the client side interface, but it is also possible to pass URIs explicitly to the proxy through the
          use of the <classname>org.jboss.resteasy.annotations.ClientURI</classname> annotation. For example, let 
          <classname>TestResource</classname> be a client side interface and <classname>TestResourceImpl</classname> a server resource:
      </para>
      
      <programlisting>
   @Path("")
   public interface TestResource {
      
      @GET
      @Path("dispatch")
      public String dispatch(@ClientURI String uri);
   }
   
   @Path("")
   public static class TestResourceImpl {
      
      @GET
      @Path("a")
      public String a() {
         return "a";
      }
      
      @GET
      @Path("b")
      public String b() {
         return "b";
      }
   }
      </programlisting>
      
      <para>
          Calling <methodname>TestResource.dispatch()</methodname> allows specifying a specific URI for accessing a resource method. In the
          following, let BASE_URL be the address of the <classname>TestResourceImpl</classname> resource.
      </para>
      
      <programlisting>
   private static String BASE_URL = "http://localhost:8081/";
   ...
   public void test() throws Exception
   {
      ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();
      TestResource proxy = client.target(BASE_URL).proxy(TestResource.class);
      String name = proxy.dispatch(BASE_URL + "a");
      System.out.println("name: " + name);
      name = proxy.dispatch(BASE_URL + "b");
      System.out.println("name: " + name);
      client.close();
   }
      </programlisting>
      
      <para>
          Then passing "http://localhost:8081/a" and "http://localhost/b" to <methodname>dispatch()</methodname> invokes
          <methodname>TestResourceImp.a()</methodname> and <methodname>TestResourceImpl.b()</methodname> respectively, yielding
          the output
      </para>
      
      <programlisting>
name: a
name: b
      </programlisting>
    </section>
    
    <section id="Sharing_interfaces">
        <title>Sharing an interface between client and server</title>
        <para>
            It is generally possible to share an interface between the client and server. In this scenario, just
            have the &REST-API; services implement an annotated interface
            and then reuse that same interface to create client proxies to invoke on the client-side.
        </para>

    </section>
    </section>
    
    
    

   
   <section id="transport_layer">
     <title>Apache HTTP Client 4.x and other backends</title>
       <warning>
           <para>
               <emphasis role="bold">Note: </emphasis> The Apache HTTP Client support is deprecated in RESTEasy. The exposed
               API's will eventually be removed. However, it's still the default client implementation as we prepare for
               a replacement backing HTTP client.
           </para>
       </warning>

       <para>
           Network communication between the client and server is handled by default in RESTEasy.
           The interface between the RESTEasy Client Framework and the network
           is defined by RESTEasy's <code class="classname">ClientHttpEngine</code> interface.
           RESTEasy ships with multiple implementations of this interface.
       </para>
       <para>
           The default
           implementation is <code class="classname">ApacheHttpClient43Engine</code>, which uses
           version 4.3 of the <code class="classname">HttpClient</code> from the Apache
           <code class="classname">HttpComponents</code> project.
       </para>
       <para>
           <code class="classname">ApacheHttpAsyncClient4Engine</code>, instead, is built on top
           of <emphasis>HttpAsyncClient</emphasis> (still from the Apache
           <emphasis>HttpComponents</emphasis> project) with internally dispatches requests
           using a non-blocking IO model.
       </para>
       <para>
           <code class="classname">JettyClientEngine</code> is built on top
           of <emphasis>Eclipse Jetty</emphasis> HTTP engine, which is possibly an interesting
           option for those already running on the Jetty server.
       </para>
       <para>
           <code class="classname">VertxClientHttpEngine</code> is built on top
           of <emphasis>Eclipse Vert.x</emphasis>, which provides a non-blocking HTTP client based
           on Vert.x framework.
       </para>
       <para>
           <code class="classname">ReactorNettyClientHttpEngine</code> is built on top
           of <emphasis>Reactor Netty</emphasis>, which provides a non-blocking HTTP client based
           on Netty framework.
       </para>

       <table frame="topbot">
           <tgroup cols="2" rowsep="1" colsep="1">
               <thead>
                   <row>
                       <entry>RESTEasy ClientHttpEngine implementations</entry>
                       <entry></entry>
                   </row>
               </thead>
               <tbody>
                   <row>
                       <entry>ApacheHttpClient43Engine (deprecated)</entry>
                       <entry>Uses HttpComponents HttpClient 4.3+</entry>
                   </row>
                   <row>
                       <entry>ApacheHttpAsyncClient4Engine (deprecated)</entry>
                       <entry>Uses HttpComponents HttpAsyncClient</entry>
                   </row>
                   <row>
                       <entry>JettyClientEngine</entry>
                       <entry>Uses Eclipse Jetty</entry>
                   </row>
                   <row>
                       <entry>ReactorNettyClientHttpEngine</entry>
                       <entry>Uses Reactor Netty</entry>
                   </row>
                 <row>
                   <entry>VertxClientHttpEngine</entry>
                   <entry>Uses Eclipse Vert.x</entry>
                 </row>
                   <row>
                       <entry>URLConnectionEngine</entry>
                       <entry>Uses java.net.HttpURLConnection</entry>
                   </row>
               </tbody>
           </tgroup>
       </table>

       <para>
           The RESTEasy Client Framework can also be customized.  The user can provide
           their own implementations of
           <code class="classname">ClientHttpEngine</code> to the
           <code class="classname">ResteasyClient</code>.
       </para>

       <programlisting>
ClientHttpEngine myEngine = new ClientHttpEngine() {
    protected SSLContext sslContext;
    protected HostnameVerifier hostnameVerifier;


    @Override
    public ClientResponse invoke(ClientInvocation request) {
        // implement your processing code and return a
        // org.jboss.resteasy.client.jaxrs.internal.ClientResponse
        // object.
    }

    @Override
    public SSLContext getSslContext() {
       return sslContext;
    }

    @Override
    public HostnameVerifier getHostnameVerifier() {
       return hostnameVerifier;
    }

    @Override
    public void close() {
       // do nothing
    }
};

ResteasyClient client = ((ResteasyClientBuilder)ClientBuilder.newBuilder()).httpEngine(myEngine).build();
       </programlisting>

       <para>
           RESTEasy and <classname>HttpClient</classname> make reasonable default decisions so
           that it is possible to use the client framework without ever referencing
           <classname>HttpClient</classname>. For some applications it may be necessary to drill
           down into the <classname>HttpClient</classname> details.
           <classname>ApacheHttpClient43Engine</classname> can
           be supplied with an instance of
           <classname>org.apache.http.client.HttpClient</classname> and an instance of
           <classname>org.apache.http.protocol.HttpContext</classname>, which can carry
           additional configuration details into the <classname>HttpClient</classname> layer.

       </para>
           <classname>HttpContextProvider</classname>
           is a RESTEasy provided interface through which a custom
           <classname>HttpContext</classname> is supplied to
           <classname>ApacheHttpClient43Engine</classname>.
       <para>

       <programlisting>
package org.jboss.resteasy.client.jaxrs.engines;

import org.apache.http.protocol.HttpContext;

public interface HttpContextProvider {
   HttpContext getContext();
}
       </programlisting>

       </para>

       <para>
           Here is an example of providing a custom HttpContext
       </para>

       <programlisting>
DefaultHttpClient httpClient = new DefaultHttpClient();
ApacheHttpClient43Engine engine = new ApacheHttpClient43Engine(httpClient,
   new HttpContextProvider() {
           @Override
           public HttpContext getContext() {
              // Configure HttpClient to authenticate preemptively
              // by prepopulating the authentication data cache.
              // 1. Create AuthCache instance
              AuthCache authCache = new BasicAuthCache();
              // 2. Generate BASIC scheme object and add it to the local auth cache
              BasicScheme basicAuth = new BasicScheme();
              authCache.put(getHttpHost(url), basicAuth);
              // 3. Add AuthCache to the execution context
              BasicHttpContext localContext = new BasicHttpContext();
              localContext.setAttribute(ClientContext.AUTH_CACHE, authCache);
              return localContext;
           }
});
       </programlisting>
       <section id="http_redirect">
      <title>HTTP redirect</title>
      <para>
         The <classname>ClientHttpEngine</classname> implementations based on Apache
         <classname>HttpClient</classname> support HTTP redirection.
         The feature is disabled by default and has to be enabled by users explicitly.
          Either by setting up the following property:
          <itemizedlist>
              <listitem><classname>dev.resteasy.client.follow.redirects</classname></listitem>
          </itemizedlist>
          <programlisting>
Client client = ClientBuilder.newBuilder().property("dev.resteasy.client.follow.redirects", "true").build();
          </programlisting>
          or by explicitly calling the API method as following:
         <programlisting>
ApacheHttpClient43Engine engine = new ApacheHttpClient43Engine();
engine.setFollowRedirects(true);
Client client = ((ResteasyClientBuilder)ClientBuilder.newBuilder()).httpEngine(engine).build();
     </programlisting>
      </para>
    </section>
    <section id="https">
        <title>Configuring SSL</title>
        <para>
            To enable SSL on client, a <classname>ClientHttpEngine</classname> containing a SSLContext can be created to build
            client as in the following example:
            <programlisting>
ClientHttpEngine myEngine = new ClientHttpEngine() {
   ...
   public void setSslContext(SSLContext sslContext) {
      this.sslContext = sslContext;
   }

   @Override
   public HostnameVerifier getHostnameVerifier() {
      return hostnameVerifier;
   }
};
myEngine.setSslContext(mySslContext)
ResteasyClient client = ((ResteasyClientBuilder)ClientBuilder.newBuilder()).httpEngine(myEngine).build();
            </programlisting>
            An alternative is to set up a keystore and truststore and pass a custom SslContext to ClientBuilder:
            <programlisting>
Client sslClient = ClientBuilder.newBuilder().sslContext(mySslContext).build();
            </programlisting>
            If you don't want to create a SSLContext, you can build client with a keystore and truststore. Note if both
            SSLContext and keystore/truststore are configured, the later will be ignored by Resteasy ClientBuilder.
            <programlisting>
Client sslClient = ClientBuilder.newBuilder().keystore(keystore,mypassword).
                      trustKeystore(trustStore).build();
            </programlisting>
            During handshaking, a custom HostNameVerifier can be called to allow the connection if URL's hostname and
            the server's identification hostname match.
            <programlisting>
Client sslClient =  ((ResteasyClientBuilder)ClientBuilder.newBuilder()).sslContext(mysslContext)
                       .hostnameVerifier(myhostnameVerifier).build();
            </programlisting>
            Resteasy provides another simple way to set up a HostnameVerifier. It allows configuring ResteasyClientBuilder with
            a <classname>HostnameVerificationPolicy</classname> without creating a custom HostNameVerifier:
            <programlisting>
Client sslClient =  ((ResteasyClientBuilder)ClientBuilder.newBuilder()).sslContext(mysslContext)
                       .hostnameVerification(ResteasyClientBuilder.HostnameVerificationPolicy.ANY).build();
            </programlisting>
            <itemizedlist>
                <listitem>Setting HostnameVerificationPolicy.ANY will allow all connections without a check.</listitem>
                <listitem>HostnameVerificationPolicy.WILDCARD only allows wildcards in subdomain names i.e. *.foo.com.</listitem>
                <listitem>HostnameVerificationPolicy.STRICT checks if DNS names match the content of the Public Suffix List
            (https://publicsuffix.org/list/public_suffix_list.dat). Please note if this public suffix list isn't the check
            wanted, create your own HostNameVerifier instead of this policy setting.</listitem>
            </itemizedlist>
        </para>
    </section>
    <section id="http_proxy">
      <title>HTTP proxy</title>
      <para>
         The <classname>ClientHttpEngine</classname> implementations based on Apache
         <classname>HttpClient</classname> support HTTP proxy.
         This feature can be enabled by setting specific properties on the builder:
         <itemizedlist>
         	<listitem><classname>org.jboss.resteasy.jaxrs.client.proxy.host</classname></listitem>
         	<listitem><classname>org.jboss.resteasy.jaxrs.client.proxy.port</classname></listitem>
         	<listitem><classname>org.jboss.resteasy.jaxrs.client.proxy.scheme</classname></listitem>
         </itemizedlist>
         <programlisting>
Client client = ClientBuilder.newBuilder().property("org.jboss.resteasy.jaxrs.client.proxy.host", "someproxy.com").property("org.jboss.resteasy.jaxrs.client.proxy.port", 8080).build();
     </programlisting>
      </para>
    </section>
    <section id="apache_4_3">
        <title>Apache HTTP Client 4.3 APIs</title>
     <para>
         The RESTEasy Client framework automatically creates and properly configures the underlying
         Apache HTTP Client engine. When the <classname>ApacheHttpClient43Engine</classname> is
         manually created, though, the user can either let it build and use a default
         <classname>HttpClient</classname> instance or provide a custom one:
     </para>
     <programlisting>
public ApacheHttpClient43Engine() {
   ...
}

public ApacheHttpClient43Engine(HttpClient httpClient) {
   ...
}

public ApacheHttpClient43Engine(HttpClient httpClient, boolean closeHttpClient) {
   ...
}
     </programlisting>
     <para>
         The <emphasis>closeHttpClient</emphasis> parameter on the last constructor above allows controlling
         whether the Apache <classname>HttpClient</classname> is to be closed upon engine finalization.
         The default value is <emphasis>true</emphasis>. When a custom <classname>HttpClient</classname>
         instance is not provided, the default instance will always be closed together with the engine.
     </para>

     <para>
         For more information about HttpClient (4.x), see the documentation
         at <ulink url="https://hc.apache.org/index.html">
         https://hc.apache.org/index.html/</ulink>.
     </para>
     
     <para>
         <emphasis role="bold">Note.</emphasis> It is important to understand
         the difference between "releasing" a connection and "closing" a
         connection.  <emphasis role="bold">Releasing</emphasis> a connection
         makes it available for reuse.  <emphasis role="bold">Closing</emphasis>
         a connection frees its resources and makes it unusable.
     </para>

     <para>
         If an execution of a request or a call on
         a proxy returns a class other than <classname>Response</classname>,
         then RESTEasy will take care of releasing the connection.  For example,
         in the fragments
     </para>
     
     <programlisting>
WebTarget target = client.target("http://localhost:8081/customer/123");
String answer = target.request().get(String.class);
     </programlisting>
     
     <para>
         or
     </para>
     
     <programlisting>
ResteasyWebTarget target = client.target("http://localhost:8081/customer/123");
RegistryStats stats = target.proxy(RegistryStats.class);
RegistryData data = stats.get();
     </programlisting>
     
     <para>
        RESTEasy will release the connection under the covers.  The only counterexample is the case
        in which the response is an instance of <classname>InputStream</classname>, which must
        be closed explicitly.
     </para>
     
     <para>
         On the other hand, if the result of an invocation is an instance of
         <classname>Response</classname>, then the Response.close() method must be used to release the connection.
     </para>
     
     <programlisting>
WebTarget target = client.target("http://localhost:8081/customer/123");
Response response = target.request().get();
System.out.println(response.getStatus());
response.close();
     </programlisting>
     
     <para>
         It is advisable to execute this in a try/finally block.  Again, releasing a connection only makes it available
         for another use. <emphasis role="bold">It does not normally close the socket.</emphasis>
     </para>
         
     <para>
         On the other hand,
         <methodname>ApacheHttpClient43Engine.finalize()</methodname> will close any open
         sockets, unless the user set <emphasis>closeHttpClient</emphasis> as <emphasis>false</emphasis> when building
         the engine, in which case he is responsible for closing the connections.
     </para>
     
     <para>
         Note that if <classname>ApacheHttpClient43Engine</classname> has created its own
         instance of <classname>HttpClient</classname>, it is not necessary to wait
         for <methodname>finalize()</methodname> to close open sockets.  The
         <classname>ClientHttpEngine</classname> interface has a <methodname>close()</methodname>
         method for this purpose.
     </para>

    <para>
        If the user's jakarta.ws.rs.client.Client class has created the engine automatically, the user should
        call Client.close() and this will clean up any socket connections.
    </para>

    <para>
        Finally, having explicit <methodname>finalize()</methodname> methods can badly affect performances, the
        <classname>org.jboss.resteasy.client.jaxrs.engines.ManualClosingApacheHttpClient43Engine</classname> flavour
        of <classname>org.jboss.resteasy.client.jaxrs.engines.ApacheHttpClient43Engine</classname> can be used. With
        that the user is always responsible for calling <methodname>close()</methodname> as no <methodname>finalize()</methodname>
        is there to do that before object garbage collection.
    </para>

    </section>

    <section id="apache_asynch">
        <title>Asynchronous HTTP Request Processing</title>
        <para>
            RESTEasy's default async engine implementation class is
            <emphasis>ApacheHttpAsyncClient4Engine</emphasis>.  It can be set as the active
            engine by calling method <emphasis>useAsyncHttpEngine</emphasis> in
            <emphasis>ResteasyClientBuilder</emphasis>.
        </para>
        <programlisting>
    Client asyncClient = ((ResteasyClientBuilder)ClientBuilder.newBuilder()).useAsyncHttpEngine()
                             .build();
    Future&lt;Response&gt; future = asyncClient
                             .target("http://locahost:8080/test").request()
                             .async().get();
    Response res = future.get();
    Assert.assertEquals(HttpResponseCodes.SC_OK, res.getStatus());
    String entity = res.readEntity(String.class);
        </programlisting>
        <sect2>
            <title>InvocationCallbacks</title>
            <para>
                InvocationCallbacks are called from within the io-threads and thus must not block or else
                the application may slow down to a halt. Reading the response is safe because the response
                is buffered in memory, as are other async and in-memory client-invocations that submit-calls
                returning a future not containing Response, InputStream or Reader.
            </para>
            <programlisting>
   final CountDownLatch latch = new CountDownLatch(1);
   Future&lt;String&gt; future = nioClient.target(generateURL("/test")).request()
         .async().get(new InvocationCallback&lt;String&gt;()
                {
                   @Override
                   public void completed(String s)
                   {
                      Assert.assertEquals("get", s);
                      latch.countDown();
                      throw new RuntimeException("for the test of it");
                   }

                   @Override
                   public void failed(Throwable error)
                   {
                   }
                });
   String entity = future.get();
   Assert.assertEquals("get", entity);
            </programlisting>
            <para>
                InvocationCallbacks may be called seemingly "after" the future-object returns. Thus, responses
                should be handled solely in the InvocationCallback.
            </para>
            <para>
                InvocationCallbacks will see the same result as the future-object and vice versa. Thus, if the
                invocationcallback throws an exception, the future-object will not see it. This is the
                reason to handle responses only in the InvocationCallback.
            </para>

        </sect2>

        <sect2>
            <title>Async Engine Usage Considerations</title>
            <para>
                Asynchronous IO means non-blocking IO utilizing few threads, typically at most as many
                threads as number of cores.  As such, performance may profit from fewer thread switches
                and less memory usage due to fewer thread-stacks. But doing synchronous, blocking IO (the
                invoke-methods not returning a future) may suffer, because the data has to be transferred
                piecewise to/from the io-threads.
            </para>
            <para>
                Request-Entities are fully buffered in memory, thus <emphasis>HttpAsyncClient</emphasis>
                is unsuitable for very large uploads.  Response-Entities are buffered in memory, except
                if requesting a Response, InputStream or Reader as Result. For large downloads or
                COMET, one of these three return types must be requested, but there may be a performance
                penalty because the response-body is transferred piecewise from the io-threads. When
                using InvocationCallbacks, the response is always fully buffered in memory.
            </para>
        </sect2>
    </section>

    <section id="jetty_client">
        <title>Jetty Client Engine</title>
        <para>
            As a drop in replacement, RESTEasy allows selecting a Jetty 9.4+ based HTTP engine.
            The Jetty implementation is newer and less tested, but it may end up being a good choice
            when relying on Jetty as server side already.  The Jetty Server can even share execution
            resources with Client libraries if configured to use e.g. the same QueuedThreadPool.
        </para>
        <para>
            The Jetty engine is enabled by adding a dependency to the <emphasis>org.jboss.resteasy:resteasy-client-jetty</emphasis>
            artifact to the Maven project; then the client can be built as follows:
        </para>
        <programlisting>
ResteasyClient client = ((ResteasyClientBuilder)ClientBuilder.newBuilder()).clientEngine(
   new JettyClientEngine(new HttpClient())).build();
        </programlisting>
    </section>

     <section id="vertx_client">
         <title>Vertx Client Engine</title>
         <para>
           Still as a drop in replacement, RESTEasy allows selecting a Vert.x-based HTTP engine.
           The Vert.x implementation can perform asynchronous client invocations. It provides the following features:
         </para>
         <itemizedlist>
             <listitem>
                 <para>HTTP/1.1</para>
             </listitem>
             <listitem>
                 <para>HTTP/2</para>
             </listitem>
             <listitem>
                 <para>SSL/TLS (including native SSL engine)</para>
             </listitem>
             <listitem>
                 <para>Efficient client connection pooling</para>
             </listitem>
             <listitem>
                 <para>Optional native IO on Linux and BSD for greater performance</para>
             </listitem>
             <listitem>
                 <para>Domain sockets</para>
             </listitem>
             <listitem>
                 <para>HTTP Metrics with Dropwizard or Micrometer</para>
             </listitem>
         </itemizedlist>
         <para>
           The Vert.x engine is enabled by adding a dependency to the <emphasis>org.jboss.resteasy:resteasy-client-vertx</emphasis>
           artifact to the Maven project; then the client can be built as follows:
         </para>
         <programlisting>
VertxClientHttpEngine engine = new VertxClientHttpEngine();
ResteasyClient client = ((ResteasyClientBuilder)ClientBuilder.newBuilder())
  .clientEngine(engine).build();
         </programlisting>
         <para>
           A Vert.x instance can also be provided when creating the client engine, as well as options configuration:
         </para>
         <programlisting>
HttpClientOptions options = new HttpClientOptions()
 .setSsl(true);
 .setTrustStoreOptions(new JksOptions()
   .setPath("/path/to/your/truststore.jks")
   .setPassword("password-of-your-truststore")
);
VertxClientHttpEngine engine = new VertxClientHttpEngine(vertx, options);
         </programlisting>
       <para>You can read more about HttpClient configuration <ulink url="https://vertx.io/docs/vertx-core/java/#_making_requests">here</ulink>.</para>
     </section>

    <section id="reactor_netty_client">
        <title>Reactor Netty Client Engine</title>
        <para>
            Still as a drop in replacement, RESTEasy allows selecting a Reactor Netty based HTTP engine.
            The Reactor Netty implementation is newer and less tested, but can be a good choice if the user
            application is already depending on Netty and performs asynchronous client invocations.
        </para>
        <para>
            The Reactor Netty engine is enabled by adding a dependency to the <emphasis>org.jboss.resteasy:resteasy-client-reactor-netty</emphasis>
            artifact to the Maven project; then the client can be built as follows:
        </para>
        <programlisting>
ReactorNettyClientHttpEngine engine = new ReactorNettyClientHttpEngine(
   HttpClient.create(),
   new DefaultChannelGroup(new DefaultEventExecutor()),
   HttpResources.get());
ResteasyClient client = ((ResteasyClientBuilder)ClientBuilder.newBuilder())
   .clientEngine(engine).build();
        </programlisting>
        <para>
            When coupled with the MonoRxInvoker, this has several benefits.
            It supports things like this:
<programlisting>
webTarget.path("/foo").get().rx(MonoRxInvoker.class).map(...).subscribe()
</programlisting>

        <para>
            in order to achieve non-blocking HTTP client calls. This allows leveraging
            some reactor features:
        </para>
<itemizedlist>
    <listitem>the ability for a <code>Mono#timeout</code> set on the response to aggressively terminate the HTTP request;</listitem>
    <listitem>the ability to pass a (reactor) context from client calls into <classname>ReactorNettyClientHttpEngine</classname>.</listitem>
</itemizedlist>
        </para>
        
        <para>
        For some sample code, see 
        <classname>org.jboss.resteasy.reactor.ReactorTest</classname> in the
        RESTEasy module resteasy-reactor.
        </para>
    </section>

   </section>

    <section id="client-utilities">
        <title>Client Utilities</title>
        <para>
            The client utilities contain various client side helpers that can be registered on a client. These utilities
            do not require RESTEasy and can be used with any Jakarta RESTful Web Services implementation.
        </para>
        <section id="client-utilities-auth">
            <title>Client Authentication</title>
            <para>
                The client authentication utilities can be used on a client when an endpoint requires authentication.
                Currently, BASIC and DIGEST authentication are supported.
                <programlisting>
try (
        Client client = ClientBuilder.newBuilder()
                .register(HttpAuthenticators.basic(UserCredentials.clear("user", new char[] {'p', 'a', 's', 's', 'w', 'o', 'r', 'd'})))
                .build()
    ) {
    final Response response = client.target("https://example.com/api/info")
            .request(MediaType.APPLICATION_JSON_TYPE)
            .get();
}
                </programlisting>
                <programlisting>
final Response response = client.target("https://example.com/api/info")
        .register(HttpAuthenticators.digest(UserCredentials.clear("user", new char[] {'p', 'a', 's', 's', 'w', 'o', 'r', 'd'})))
        .request(MediaType.APPLICATION_JSON_TYPE)
        .get();
                </programlisting>
            </para>
        </section>
    </section>

</chapter>

